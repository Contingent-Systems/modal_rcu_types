\makeatletter % allow us to mention @-commands
\def\arcr{\@arraycr}
\makeatother
\section{Evaluation}
\label{sec:eval}
We have used our type system to check correct use of RCU primitives in two RCU data structures representative of the broader space.

Figure \ref{fig:rculist} gives the type-annotated code for \lstinline|add| and \lstinline|remove| operations on a linked list implementation of a bag data structure, following McKenney's example~\cite{McKenney2015SomeEO}.
Appendix \ref{appendix:bag_paul} contains the code for membership checking.

We have also type checked the most challenging part of an RCU binary search tree, the deletion (which also contains the code for a lookup).
Our implementation is a slightly simplified version of the Citrus BST~\cite{Arbel:2014:CUR:2611462.2611471}: their code supports fine-grained locking for multiple writers, while ours supports only one writer by virtue of using our single-writer primitives.
For lack of space the annotated code is only in Appendix \ref{appendix:bst_del}, but it motivates some of the conditional-related flexibility discussed in Section \ref{subsection:type-action}.
The use of disjunction ($Left|Right$) in field maps and paths is required to capture traversals which follow different fields at different times, such as the lookup in a binary search tree.
\begin{figure}[H]
\centering 
\noindent
\begin{subfigure}[b]{.4\linewidth}
\centering
\begin{tikzpicture}[scale=1]
\tikzstyle{hollow node}=[circle,draw,inner sep=1.5]
\tikzstyle{sub node}=[triangle,draw,inner sep=1.5]
\tikzstyle{solid node}=[rectangle,draw,inner sep=1.5]
\tikzset{
  red node/.style = {rectangle,draw=red,inner sep=1.5},
  treenode/.style = {circle, draqw=black, align=center, minimum size=0.1cm},
  subtree/.style  = {isosceles triangle, draw=black, align=center, minimum height=0.5cm, minimum width=0.5cm, shape border rotate=90, anchor=north},
  succn/.style = {circle,draw=purple,fill=purple,inner sep=0.2},
  blue node/.style = {rectangle,draw=blue,inner sep=1.5}
}

    \node[hollow node]       (r)     []   { };
    \node[subtree]           (t1)    [below left of=r]       {$T_{1}$};
    \node[hollow node]           (k)    [below right of=r]      {$k$};
    \node[subtree]             (kl)    [below left of=k]      {$T_{2}$};
\node[hollow node]          (kr)    [below right of = k]  { };
    \node[hollow node]             (krl)         [below left of = kr]        {$k'$};
    \node[subtree]          (krr)       [below right of = kr]           {$T_{3}$};
    \path[->]  
	     (r)     edge node {} (t1)
                (r)     edge node {} (k)
                (k)    edge node {} (kl)
	     (k)    edge node {} (kr)
	    (kr)    edge node {}  (krl)
                (kr)     edge node {} (krr)
;
\end{tikzpicture}
\caption{Node $k$ with its successor $k'$}
\label{fig:del2.1}
\end{subfigure}\quad
\begin{subfigure}[b]{.4\linewidth}
\centering
\begin{tikzpicture}[scale=1]
\tikzstyle{hollow node}=[circle,draw,inner sep=1.5]
\tikzstyle{sub node}=[triangle,draw,inner sep=1.5]
\tikzstyle{solid node}=[rectangle,draw,inner sep=1.5]

\tikzset{
  red node/.style = {circle,draw=red,inner sep=1.5},
  treenode/.style = {circle, draqw=black, align=center, minimum size=0.1cm},
  subtree/.style  = {isosceles triangle, draw=black, align=center, minimum height=0.25cm, minimum width=0.25cm, shape border rotate=90, anchor=north},
  succn/.style = {circle,draw=purple,fill=purple,inner sep=0.2},
  blue node/.style = {circle,draw=blue,inner sep=1.5}
}

    \node[hollow node]       (r)     []   { };
    \node[subtree]           (t1)    [below left of=r]       {$T_{1}$};
    \node[hollow node]           (k)    [below right of=r]      {$k$};
    \node[blue node]            (kp1) [right of = k]   {$f'$};    
    \node[subtree]             (kl)    [below left of=k]      {$T_{2}$};
\node[hollow node]          (kr)    [below right of = k]  { };
    \node[hollow node]             (krl)         [below left of = kr]        {$k'$};
    \node[subtree]          (krr)       [below right of = kr]           {$T_{3}$};
    \path[->]  
	     (r)     edge node {} (t1)
                (r)     edge node {} (k) 
                (k)    edge node {} (kl)
	     (k)    edge node {} (kr)
	    (kr)    edge node {}  (krl)
                (kr)     edge node {} (krr)
                (kp1)   edge[dashed,draw=blue] node {} (kr)
	     (kp1)    edge[dashed,draw=blue] node {} (kl)
;
\end{tikzpicture}
\caption{Duplicating $k'$ with a fresh variable $f'$}
\label{fig:del2.2}
\end{subfigure}
\begin{subfigure}[b]{.4\linewidth}
\centering
\begin{tikzpicture}[scale=1]
\tikzstyle{hollow node}=[circle,draw,inner sep=1.5]
\tikzstyle{sub node}=[triangle,draw,inner sep=1.5]
\tikzstyle{solid node}=[rectangle,draw,inner sep=1.5]

\tikzset{
  red node/.style = {circle,draw=red,inner sep=1.5},
  treenode/.style = {circle, draqw=black, align=center, minimum size=0.1cm},
  subtree/.style  = {isosceles triangle, draw=black, align=center, minimum height=0.5cm, minimum width=0.5cm, shape border rotate=90, anchor=north},
  succn/.style = {circle,draw=purple,fill=purple,inner sep=0.2},
  blue node/.style = {circle,draw=blue,inner sep=1.5}
}

    \node[hollow node]       (r)     []   { };
    \node[subtree]           (t1)    [below left of=r]       {$T_{1}$};
    \node[red node]           (k)    [below right of=r]      {$k$};
    \node[hollow node]            (kp1) [right of = k]   {$f'$};    
    \node[subtree]             (kl)    [below left of=k]      {$T_{2}$};
\node[hollow node]          (kr)    [below right of = k]  { };
    \node[hollow node]             (krl)         [below left of = kr]        {$k'$};
    \node[subtree]          (krr)       [below right of = kr]           {$T_{3}$};
    \path[->]  
	     (r)     edge node {} (t1)
                (r)     edge node {} (kp1) 
                (k)    edge[dashed,draw=red] node {} (kl)
	     (k)    edge[dashed,draw=red] node {} (kr)
	    (kr)    edge node {}  (krl)
                (kr)     edge node {} (krr)
                (kp1)   edge node {} (kr)
	     (kp1)    edge node {} (kl)
;
\end{tikzpicture}
\caption{ Unlinking $k$ via linking fresh variable  $f'$.}
\label{fig:del2.3}
\end{subfigure}\quad
\begin{subfigure}[b]{.4\linewidth}
\centering
\begin{tikzpicture}[scale=1]
\tikzstyle{hollow node}=[circle,draw,inner sep=1.5]
\tikzstyle{sub node}=[triangle,draw,inner sep=1.5]
\tikzstyle{solid node}=[rectangle,draw,inner sep=1.5]

\tikzset{
  red node/.style = {rectangle,draw=red,inner sep=1.5},
  treenode/.style = {circle, draqw=black, align=center, minimum size=0.1cm},
  subtree/.style  = {isosceles triangle, draw=black, align=center, minimum height=0.5cm, minimum width=0.5cm, shape border rotate=90, anchor=north},
  succn/.style = {circle,draw=purple,fill=purple,inner sep=0.2},
  blue node/.style = {rectangle,draw=blue,inner sep=1.5}
}

    \node[hollow node]       (r)     []   { };
    \node[subtree]           (t1)    [below left of=r]       {$T_{1}$};
    \node[hollow node]            (kp1) [below right of = r]   {$f'$};    
    \node[subtree]             (kl)    [below left of=kp1]      {$T_{2}$};
    \node[hollow node]          (kr)    [below right of = kp1]  { };
    \node[subtree]          (krr)       [below right of = kr]           {$T_{3}$};
    \path[->]  
	     (r)     edge node {} (t1)
         (r)     edge node {} (kp1) 
         (kr)     edge node {} (krr)
         (kp1)   edge node {} (kr)
	     (kp1)    edge node {} (kl)
;
\end{tikzpicture}
\captionof{figure}{Reclamation of $k$ after waiting all readers on it.}
\label{fig:del2.4}
\end{subfigure}
\caption{\textsf{Delete} of the node with two children}
\label{fig:del2}
\end{figure}

The most subtle aspect of the deletion is the final step in the case the node $R$ to remove has both children.  In this case, the value $V$ of the left-most node of $R$'s right child --- the next element in the collection order --- is copied into a new node, which is then used to \emph{replace} node $R$: the replacement's fields exactly match $R$'s except for the data (\textsc{T-Replace} via $\N_1 = \N_2$), and the parent is updated to reference the replacement, unlinking $R$.  At this point, there are two nodes with value $V$ in the tree (\textit{weak} BST property of the Citrus~\cite{Arbel:2014:CUR:2611462.2611471}): the replacement node, and what was the left-most node under $R$'s right child. This latter (original) node for $V$ must be unlinked, which is simplified because by being left-most the left child is null, avoiding another round of replacement (\textsc{T-UnlinkH} via $\forall_{f\in dom(\N_1)} \ldotp f\neq f_2 \implies (\N_1(f) = \textsf{null}$).
The complexity in checking safety here is that once $R$ is found, another loop is used to find $V$ and its parent (since that node will later be removed as well).
After $V$ is found, there are \emph{two} local unlinking operations, at different depths of the tree.  This is why the type system must keep separate abstract iteration counts for traversals in loops --- these indices act like multiple cursors into the data structure, and allow the types to carry enough information to keep those changes separate and ensure neither introduces a cycle.

To the best of our knowledge, we are the first to check such code for memory-safe use of RCU primitives modularly, without appeal to the specific implementation of RCU primitives.

