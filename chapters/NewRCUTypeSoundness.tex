\section{Soundness}
\label{sec:soundness}
This section outlines the proof of type soundness -- our full proof appears in Appendices \ref{sec:prooflemmas}, \ref{sec:memaxioms}, \ref{lem:lematom} and \ref{lem:lemstructural}.
We prove type soundness by embedding the type system into an abstract concurrent separation logic called the Views Framework~\cite{views}, which when given certain information about proofs for a specific language (primitives and primitive typing) gives back a full program logic including choice and iteration.  As with other work taking this approach~\cite{oopsla12,toplas17}, this consists of several key steps:
\begin{enumerate}
    \item Define runtime states and semantics for the atomic actions of the language.  These are exactly the semantics from Figure \ref{fig:operationalsemrcu} in Section \ref{sec:semantics}
    \item Define a denotational interpretation $\db{-}$ of the types (Figure \ref{fig:denotingtypeenviroment}) in terms of an \emph{instrumented} execution state -- a runtime state (Section \ref{sec:semantics}) with additional bookkeeping to simplify proofs.  
    The denotation encodes invariants specific to each type, like the fact that \textsf{unlinked} references are unreachable from the heap. %, or that \textsf{freeable} references are unreachable from the heap as well as other threads' local variables.
    The instrumented execution states are also constrained by additional \textit{global} \textsf{WellFormed}ness \textit{invariants} (Appendix \ref{sec:memaxioms}) the type system is intended to maintain, such as tree structure of the data structure.
    \item Prove a lemma -- called \emph{Axiom Soundness} (Lemma \ref{lem:axmsoundness}) -- that the type rules for atomic actions are sound.  Specifically, that given a state in the denotation of the pre-type-environment of a primitive type rule, the operational semantics produce a state in the denotation of the post-type-environment.  This includes preservation of global invariants.
    \item Give a desugaring $\downarrow-\downarrow$ of non-trivial control constructs (Figure \ref{fig:asm}) into the simpler non-deterministic versions provided by Views.
\end{enumerate}
The top-level soundness claim then requires proving that every valid source typing derivation corresponds to a valid derivation in the Views logic:
$
    \forall \Gamma,C,\Gamma', \Gamma\vdash_M C \dashv \Gamma' \Rightarrow \{\db{\Gamma}\}\downarrow C\downarrow\{\db{\Gamma'}\}
$.
%The judgment $\assert{-}~C~\assert{-}$ is a claim in the abstract separation logic provided by the Views Framework, which is sound as long as the earlier steps satisfy some natural consistency properties (this is a result of the Views Framework itself~\cite{views}).
Because the parameters given to the Views framework ensure the Views logic's Hoare triples $\{-\}C\{-\}$ are sound, this proves soundness of the type rules with respect to type denotations.
Because our denotation of types encodes the property that the post-environment of any type rule accurately characterizes which memory is linked vs. unlinked, etc., and the global invariants ensure all allocated heap memory is reachable from the root or from some thread's stack, this entails that our type system prevents memory leaks.
\looseness=-1

\subsection{Invariants of RCU Views and Denotations of Types}
\label{sec:lemmas}
In this section we aim to convey an intiution on the \textit{soundness} of the type system through an informal summarization of the global \textsf{WellFormed}ness invariants together with the denotations of the types imposed on the instrumented states in the proof. Full formal details of the global \textsf{WellFormed}ness appear in Appendix \ref{sec:memaxioms}.

\mypar{The Invariant for Read Traversal} All reader threads have to access to a valid heap location even during the grace period. The validity of their heap accesses ensured by the observations they make over the heap locations which can only be \textsf{iterator} as they can only use local \textsf{rcuItr} references. To this end, \textsf{Readers-Iterators-Only} invariant asserts that a heap location can only be observed as \textsf{iterator} by the reader threads.

\mypar{Invariants on Grace-Period} We provide invariants related to the grace period based on reification of the logical free list in the instrumented state to the bounding threads in the concrete state. \textsf{Readers-In-Free-List} invariant defines the set of bounding threads via asserting its existence as a set of threads holding local references(can only be in type \textsf{rcuItr}) to a heap location in the free list. Likewise, we can also think of a bounding thread as the one to which the \textit{grace} is shown. If a reader thread observes a heap location in the free list as \textsf{iterator} then \textsf{Iterators-Free-List} invariant asserts that this thread is not a new-coming reader thread but one of the bounding threads.

The writer thread can refer to a heap location in the free list with a local reference either in type \textsf{freeable} or \textsf{unlinked}. Once the writer unlinks a heap node, it first observes the heap node as \textsf{unlinked} then \textsf{freeable}. The denotation of \textsf{freeable} type distinguishes the end of the grace period via asserting the non-existence of the bounding threads for the referent of the \textsf{freeable}. Unlike the case in the denotation of \textsf{freeable}, the type environment of \textsf{unlinked} asserts that the referent is either in the free list with some bounding threads holding references to it -- the grace period has not finished yet -- or not in the free list -- the grace period has not started yet. 

\mypar{Invariants on Safe Traversal against Unlinking} RCU write-side critical section has to guarantee that none of the updates to the heap cause invalid memory accesses. Our invariants provide reasoning over the mutated heap through possible observations made by the writer thread. \textsf{Writer-Unlink} invariant asserts that a heap location observed as \textsf{iterator} by the writer thread cannot be observed differently by other threads. The denotation of the writer thread's \textsf{rcuItr} reference, $\llbracket \mathsf{rcuItr}\,\rho \,\N \rrbracket_{tid}$, asserts that all the heap locations on the path starting from the root to the referent heap location are valid to access and can only be observed as \textsf{iterator}.

Only a bounding thread can observe a heap location in the free list as \textsf{iterator}. We introduce this obligation in the denotation of the reader thread's \textsf{rcuItr} reference, $\llbracket \mathsf{rcuItr} \rrbracket_{tid}$, and it is important in terms of  the preservation of \textsf{Readers-Iterator-Only} invariant for the set of bounding threads against unlinking as they are a subset of the reader threads. However, the unreachability of a mutated heap location for the new-coming reader threads is essential for the \textit{soundness} of the system. In this regard, a heap location which is observed as \textsf{unlinked}/\textsf{freeable} can only be accessed from a heap location that has already been mutated(can only be observed as \textsf{unlinked}/\textsf{freeable} by the writer as well). By asserting this, \textsf{Unlinked-Reachability} and \textsf{Free-List-Reachability} invariants not only prevent the reachability of the mutated heap locations for the new-coming reader threads but also support reasoning for \textit{batched-deallocation} together with the existence of the logical free list.
 
\mypar{Invariants on Safe Traversal against Inserting/Replacing} Concurrent reader threads must also not be affected by \textit{replacing-an-existing-node-with-a-fresh-one} or \textit{inserting-a-single-fresh-node}. The crucial essence in providing memory safety against these actions is enforcing unreachability of the fresh nodes until they are \textit{published/linked}. Unlike in the case of \textit{unlinking} where the reader threads can observe an unlinked heap node as \textsf{iterator} during the grace period, the reader threads cannot observe the fresh heap nodes until they are published. \textsf{Fresh-Writes} invariant asserts that a fresh heap location can only be allocated and referenced by the writer thread. The relation between a freshly allocated heap and the rest of the heap is established by \textsf{Fresh-Reachable} in such a way that there exists no heap node reaching to the freshly allocated one. This invariant supports the preservation of the tree structure. Similar to the case for unlinking, \textsf{Readers-Iterators-Only} must be preserved against inserting/replacing a fresh node and \textsf{Fresh-Not-Reader} invariant serves via asserting that the reader threads cannot observe a heap location as \textsf{fresh}. Moreover, the denotation of \textsf{rcuFresh} type, $\llbracket \mathsf{rcuFresh}\,\N \rrbracket_{tid}$, enforces the fields in $\N$ pointing to the valid heap locations(observed as \textsf{iterator} by the writer thread) to \iso{support} the soundness of the \textit{framing} relations in \textsc{T-Replace}(discussed in Figure \ref{fig:freshframeout}) and \textsc{T-Insert}.

\mypar{Invariants on Tree Structure} Our invariants enforce the \textit{tree} structure heap layouts for data structures. \textsf{Unique-Reachable} invariant asserts that every heap location reachable from root can only be reached with following an unique path. To serve for preservation of the tree structure, \textsf{Unique-Root} enforces unreachability of the root from any heap location that is reachable from root itself. 
\subsection{Proof}
\label{sec:proof}
This section provides more details on how the Views Framework~\cite{views} is used to prove soundness, giving the majore parameters to the framework and outlining key lemmas.
%The Views Framework takes a set of parameters satisfying some properties, and produces a soundness proof for a static reasoning system for a larger programming language.  Among other parameters, the most notable are the choice of machine state, semantics for \emph{atomic} actions (e.g., field writes, or \lstinline|WriteBegin|), and proofs that the reasoning (in our case, type rules) for the atomic actions are sound (in a way chosen by the framework).
%The other critical pieces are a choice for a partial \emph{view} of machine states --- usually an extended machine state with meta-information --- and a relation constraining how other parts of the program can interfere with a view (e.g., modifying a value in the heap, but not changing its type).
%Our type system will be related to the views by giving a denotation of type environments in terms of views, and then proving that for each atomic action shown in \ref{fig:operationalsemrcu} in Section \ref{sec:semantics} and type rule in Figure \ref{fig:tss} Section \ref{subsection:type-action}(also for type rules for \textit{structural} and \textit{reader critical section} in Figure \ref{fig:tssr} Appendix \ref{appendix:readtypes}), given a view in the denotation of the initial type environment of the rule, running the semantics for that action yields a local view in the denotation of the output type environment of the rule. The following works through this in more detail. We define logical states, $\textsf{LState}$ to be
Section \ref{sec:semantics} defined what Views calls \emph{atomic actions} (the primitive operations) and their semantics of runtime \emph{machine states}.  The Views Framework uses a separate notion of instrumented (logical) state over which the logic is built, related by a concretization function $\lfloor-\rfloor$ taking an instrumented state to the machine states of Section \ref{sec:semantics}.  Most often --- including in our proof ---  the logical state adds useful auxilliary state to the machine state, and the concretization is simply projection.
Thus we define our logical states \textsf{LState} as:
\begin{itemize}
\item A machine state, $\sigma=(s,h,l,rt,R,B)$;
\item An observation map, O, of type $ \textsf{Loc} \to \mathcal{P}(\textsf{obs})$
\item Undefined variable map, $U$, of type $\mathcal{P}(\textsf{Var}\times \textsf{TID})$
\item Set of threads, $T$, of type $\mathcal{P}(\textsf{TIDS})$
\item A to-free map(or free list), $F$, of type $\textsf{Loc} \rightharpoonup \mathcal{P}(\textsf{TID})$
\end{itemize}
The thread ID set $T$ includes the thread ID of all running threads.
The free map $F$ tracks which reader threads may hold references to each location. It is not required for execution of code, and for validating an implementation could be ignored, but we use it later with our type system to help prove that memory deallocation is safe.
The (per-thread) variables in the undefined variable map $U$ are those that should not be accessed (e.g., dangling pointers).

The remaining component, the observation map $O$, requires some further explanation.
Each memory allocation / object can be \emph{observed} in one of the following states by a variety of threads, depending on how it was used.
\[\textsf{obs} := \texttt{iterator} \; \mathrm{tid} \mid \texttt{unlinked} \mid \texttt{fresh} \mid \texttt{freeable} \mid \texttt{root}\]
An object can be observed as part of the structure (\texttt{iterator}), removed but possibly accessible to other threads, freshly allocated, safe to deallocate, or the root of the structure.

%We are interested in \textsf{RCU} typed of heap domain which we define as:
%\[\textsf{RCU} = \{ o \mid \textsf{FType}(f) = \textsf{RCU} \land \exists o' \ldotp h(o',f) = o \}\]

Assertions in the Views logic are (almost) sets of the logical states that satisfy a validity predicate \textsf{WellFormed}, outlined in Section \ref{sec:lemmas}:
%A thread's (or scope's) \emph{view} of memory is a subset of the instrumented(logical states), which satisfy certain \textsf{WellFormed}ness criteria relating the physical state and the additional meta-data ($O$, $U$, $T$ and $F$)
\[\mathcal{M} \stackrel{def}{=} \{ m \in (\textsf{MState} \times O \times U \times T \times F) \mid  \textsf{WellFormed}(m) \} \]

%We do our reasoning for soundness over instrumented states and define an erasure relation
%\[\lfloor - \rfloor :\mathsf{MState} \implies \textsf{LState}\]
%that projects instrumented states to the common components with \textsf{MState}.

\begin{figure}[!t]\scriptsize
\[
\begin{array}{l@{\;\;=\;\;}l}
 \llbracket \, x : \textsf{rcuItr}\,\rho\,\N \,  \rrbracket_{tid}
&
\left\{
\begin{array}{l|l}
m \in \mathcal{M}
&(\textsf{iterator} \, tid\in  O(s(x,tid)))  \land (x \notin U)  \\
& \land (\forall_{f_i\in dom(\N)  x_i\in codom(\N) } \ldotp
\left\{\begin{array}{l}  s(x_i,tid) = h(s(x,tid), f_i)  \\
 \land \textsf{iterator}\in O(s(x_i,tid)))\end{array} \right.\\
& \land  (\forall_{\rho', \rho''}\ldotp \rho'.\rho'' = \rho \implies  \textsf{iterator}\,tid \in O(h^{*}(rt,\rho'))) \\
& \land  h^{*}(rt,\rho)= s(x,tid)  \land (l = tid \land s(x,\_) \notin dom(F))) 
\end{array}
\right\}
\\
 \llbracket \, x : \textsf{rcuItr}\,  \rrbracket_{tid}
&
\left\{
\begin{array}{l|l}
m \in \mathcal{M}
&(\textsf{iterator} \, tid\in  O(s(x,tid)))  \land (x \notin U) \land \\
& (tid \in B) \implies \left\{\begin{array}{l}( \exists_{T'\subseteq B}\ldotp \{s(x,tid) \mapsto T'\} \cap F \neq \emptyset) \land \\ \land (tid \in T') \end{array}\right.
\end{array}
\right\}
\\
\llbracket \, x : \textsf{unlinked} \, \rrbracket_{tid}
&
\left\{
\begin{array}{l|l}
m \in \mathcal{M}
&(\textsf{unlinked}\in  O(.s(x,tid)) \land l = tid \land x \notin U) \land \\
& (\exists_{T'\subseteq T}\ldotp s(x,tid) \mapsto T' \in F \implies T' \subseteq B \land tid \notin T' )
\end{array}
\right\}
\\
\llbracket \, x : \textsf{freeable} \, \rrbracket_{tid}
&
\left\{
\begin{array}{l|l}
m \in \mathcal{M}
&\begin{array}{l}\textsf{freeable}\in  O(s(x,tid)) \land l = tid \land x \notin U \land \\
 s(x,tid) \mapsto \{\emptyset\} \in F \end{array}
\end{array}
\right\}
\\
\llbracket \, x : \textsf{rcuFresh} \, \N \, \,  \rrbracket_{tid}
&
\left\{
\begin{array}{l|l}
m \in \mathcal{M}
&(\textsf{fresh}\in  O(s(x,tid)) \land x \notin U  \land s(x,tid) \notin dom(F))\\
&(\forall_{f_i\in dom(\N), x_i\in codom(\N) } \ldotp s(x_i,tid) = h(s(x,tid), f_i) \\
&\land \textsf{iterator}\,tid \in O(s(x_i,tid)) \land s(x_i,tid) \notin dom(F)) 
\end{array}
\right\}
\\
\llbracket  x : \textsf{undef}\rrbracket_{tid} 
&
\left\{
\begin{array}{l|l}
m \in \mathcal{M}
&
(x,tid) \in U \land s(x,tid) \notin dom(F)
\end{array}
\right\}
\\
\llbracket \, x : \textsf{rcuRoot}\rrbracket_{tid}
&
\left\{
\begin{array}{l|l}
m \in \mathcal{M}
& \begin{array}{l}((rt \notin U \land s(x,tid) = rt \land rt \in dom(h) \land \\ 
O(rt) \in \textsf{root} \land s(x,tid) \notin dom(F) ) \end{array}
\end{array}
\right\}
\end{array}
\]
$
\textrm{provided}~h^{*}: (\textsf{Loc} \times \textsf{Path}) \rightharpoonup \textsf{Val}
$
\caption{Type Environments}
\label{fig:denotingtypeenviroment}
\vspace{-2mm}
\end{figure}

Every type environment represents a set of possible views (\textsf{WellFormed} logical states) consistent with the types in the environment.  We make this precise with a denotation function
\[\llbracket-\rrbracket\_ : \mathsf{TypeEnv}\rightarrow\mathsf{TID}\rightarrow\mathcal{P}(\mathcal{M})\]
that yields the set of states corresponding to a given type environment. This is defined as the intersection of individual variables' types as in Figure \ref{fig:denotingtypeenviroment}.
%\[\llbracket-:-\rrbracket_- : \mathsf{Var}\rightarrow\mathsf{Type}\rightarrow\mathsf{TID}\rightarrow\mathcal{P}(\mathcal{M})\]
%
%The latter is given in Figure \ref{fig:denotingtypeenviroment}.  To define the former, we first need to state what it means to combine logical machine states.

Individual variables' denotations are extended to context denotations slightly differently depending on whether the environment is a reader or writer thread context: writer threads own the global lock, while readers do not:
\begin{itemize}
\item For read-side as $\llbracket x_1 : T_1, \ldots x_n : T_n \rrbracket_{tid,\textsf{R}} = \llbracket x_1 : T_1 \rrbracket_{tid} \cap \ldots \cap \llbracket x_n : T_n \rrbracket_{tid} \cap \llbracket \textsf{R} \rrbracket_{tid}$ where
$\llbracket \textsf{R} \rrbracket_{tid} = \{ (s,h,l,rt,R,B),O,U,T,F  \mid tid \in R \}$

\item For write-side as $\llbracket x_1 : T_1, \ldots x_n : T_n \rrbracket_{tid,\textsf{M}} = \llbracket x_1 : T_1 \rrbracket_{tid} \cap \ldots \cap \llbracket x_n : T_n \rrbracket_{tid} \cap \llbracket \textsf{M} \rrbracket_{tid}$ where
$\llbracket \textsf{M} \rrbracket_{tid} = \{ (s,h,l,rt,R,B),O,U,T,F  \mid tid = l \}$
%
%\item $\llbracket x_1 : T_1, \ldots x_n : T_n \rrbracket_{tid,\textsf{O}} = \llbracket x_1 : T_1 \rrbracket_{tid} \cap \ldots \cap \llbracket x_n : T_n \rrbracket_{tid} \cap \llbracket \textsf{O} \rrbracket_{tid}$ where
%$\llbracket \textsf{O} \rrbracket_{tid} = \{ (s,h,l,rt,R,B),O,U,T,F  \mid tid \neq l \land tid \notin R \}$.
\end{itemize}

To support framing (weakening), the Views Framework requires that views form a partial commutative monoid under an operation $\bullet : \mathcal{M} \longrightarrow \mathcal{M} \longrightarrow \mathcal{M}$, provided as a parameter to the framework.
The framework also requires an interference relation $\mathcal{R}\subseteq\mathcal{M}\times\mathcal{M}$ between views to reason about local updates to one view preserving validity of adjacent views (akin to the small-footprint property of separation logic).
Figure \ref{fig:comp} defines our composition operator and the core interference relation $\mathcal{R}_0$ --- the actual inferference between views (between threads, or between a local action and framed-away state) is the reflexive transitive closure of $\mathcal{R}_0$.
Composition is mostly straightforward point-wise union (threads' views may overlap) of each component.
Interference bounds the interference writers and readers may inflict on each other.  Notably, if a view contains the writer thread, other threads may not modify the shared portion of the heap, or release the writer lock.  Other aspects of interference are natural restrictions like that threads may not modify each others' local variables.
\textsf{WellFormed} states are closed under both composition (with another \textsf{WellFormed} state) and interference ($\mathcal{R}$ relates \textsf{WellFormed} states only to other \textsf{WellFormed} states).



\begin{figure}[!t]\scriptsize
    \begin{flalign*}
      \bullet \overset{\mathrm{def}}{=} (\bullet_{\sigma},\bullet_O,\cup,\cup) \;\; (F_1 \bullet_F F_2) \overset{\mathrm{def}}{=}  F_1  \cup F_2 \texttt{   when   } dom(F_1) \cap dom(F_2) = \emptyset \\
      O_{1} \bullet_O O_{2}(loc) \overset{\mathrm{def}}{=}  O_{1}(loc) \cup O_{2}(loc) \;\;   (s_1 \bullet_s s_2) \overset{\mathrm{def}}{=}  s_1 \cup s_2 \texttt{   when   } dom(s_1) \cap dom(s_2) = \emptyset    
      \end{flalign*}
\[(h_1\bullet_h h_2)(o,f)\overset{\mathrm{def}}{=}\left\{
\begin{array}{ll}
\mathrm{undef} & \textrm{if}~h_1(o,f)=v \land h_2(o,f)=v' \land v' \neq v\\
v & \textrm{if}~h_1(o,f)=v \land h_2(o,f)=v\\
v & \textrm{if}~h_1(o,f)=\mathrm{undef}\land h_2(o,f)=v\\
v & \textrm{if}~h_1(o,f)=v\land h_2(o,f)=\mathrm{undef}\\
\mathrm{undef} & \textrm{if}~h_1(o,f)=\mathrm{undef}\land h_2(o,f)=\mathrm{undef}
\end{array}
\right.
\]
\[
\begin{array}{l}
((s,h,l,rt,R,B), O, U, T,F) \mathcal{R}_{0}((s',h',l',rt',R',B'), O', U', T',F') \overset{\mathrm{def}}{=}
\\ \bigwedge\left\{
	\begin{array}{l}
	  l  \in  T \rightarrow (h = h' \land l=l')\\
	  l\in T\rightarrow F=F'\\
	  \forall tid,o\ldotp\textsf{iterator} \, tid \in O(o) \rightarrow o \in dom(h) \\
	  \forall tid,o\ldotp\textsf{iterator} \, tid \in O(o) \rightarrow o \in dom(h') \\
          \forall tid,o\ldotp\textsf{root} \, tid \in O(o) \rightarrow o \in dom(h) \\
	  \forall tid,o\ldotp\textsf{root} \, tid \in O(o) \rightarrow o \in dom(h') \\
	  O = O' \land U = U' \land T = T'\land R =R'\land rt = rt' \\
	  \forall x, t \in T \ldotp s(x,t) = s'(x,t)
	\end{array}
\right\}
\end{array}
\]
\caption{Composition($\bullet$) and Thread Interference Relation($\mathcal{R}_{0}$)}
\label{fig:comp}
\vspace{-2mm}
\end{figure}

%\emph{Separation algebra} is a model to define and axiomatize the \emph{join/composition} operation over a domain which is \emph{set of instrumented states} in our case.


%An important property of composition is that it preserves validity of logical states:
%\begin{lemma}[\textsf{WellFormed} Composition]
%\label{lem:wf-composition}
%Any successful composition of two \textsf{WellFormed} logical states is \textsf{WellFormed}:\[\forall_{x,y,z}\ldotp \mathsf{WellFormed}(x) \implies \mathsf{WellFormed}(y) \implies x\bullet y = z \implies \mathsf{WellFormed(z)}\]
%\end{lemma}
%\begin{proof}
%In Appendix \ref{sec:prooflemmas} Lemma \ref{lem:wf-compositionap}.
%  \end{proof}

The framing/weakening type rule will be translated to a use of the frame rule in the Views Framework's logic.  There separating conjunction is simply the existence of two composable intrumented states:
%Partial separating conjunction then simply requires the existence of two states that compose:
\[ m \in P \ast Q   \stackrel{def}{=} \exists m' \ldotp \exists m'' \ldotp m' \in P \land m'' \in Q \land m \in m' \bullet m''\]
%Different threads' views of the state may overlap (e.g., on shared heap locations, or the reader thread set), but one thread may modify that shared state.  
In order to validate the frame rule in the Views Framework's logic, the assertions in its logic --- sets of well-formed instrumented states --- must be restricted to sets of logical states that are \emph{stable} with respect to expected interference from other threads or contexts, and interference must be compatible in some way with separating conjunction.
Thus a \textsf{View} --- the actual base assertions in the Views logic --- are then:
\[\textsf{View}_{\mathcal{M}} \stackrel{def}{=} \{ M \in \mathcal{P}(\mathcal{M}) | \mathcal{R}(M) \subseteq M\}\]
%Thread interference relation
%\[\mathcal{R} \subseteq \mathcal{M} \times \mathcal{M}\]  defines permissible interference on an instrumented state. The relation must distribute over composition:
Additionally, interference must distribute over composition:
\[ \forall m_{1}, m_{2}, m\ldotp (m_{1} \bullet  m_{2})\mathcal{R}m \Longrightarrow \begin{array}{ll}  \exists  m'_{1} m'_{2} \ldotp m_{1} \mathcal{R} m'_{1} \land m_{2} \mathcal{R} m'_{2} \land  m \in m'_{1} \bullet m'_{2} \end{array}\]
%where $\mathcal{R}$ is transitive-reflexive closure of $\mathcal{R}_{0}$ shown at Figure \ref{fig:comp}. $\mathcal{R}_0$ (and therefore $\mathcal{R}$) also ``preserves'' validity:

%\begin{lemma}[Valid $\mathcal{R}_0$ Interference]\label{lem:inter}
%For any $m$ and $m'$, if $\mathsf{WellFormed}(m)$ and $m\mathcal{R}_0m'$, then $\mathsf{WellFormed}(m')$.
%\end{lemma}
%\begin{proof}
%In Appendix \ref{sec:prooflemmas} Lemma \ref{lem:interap}.
%\end{proof}

Because we use this induced Views logic to prove soundness of our type system by translation, we must ensure any type environment denotes a valid view:
\begin{lemma}[Stable Environment Denotation-M]\label{lemma:stblw}
For any \emph{closed} environment $\Gamma$ (i.e., $\forall x\in\mathsf{dom}(\Gamma)\ldotp, \mathsf{FV}(\Gamma(x))\subseteq\mathsf{dom}(\Gamma)$):
$
\mathcal{R}(\llbracket\Gamma\rrbracket_{\mathsf{M},tid})\subseteq\llbracket\Gamma\rrbracket_{\mathsf{M},tid}
$.
Alternatively, we say that environment denotation is \emph{stable} (closed under $\mathcal{R}$).
\end{lemma}
\begin{proof}
In Appendix \ref{sec:prooflemmas} Lemma \ref{lemma:stblwap}.
\end{proof}
We ellide the statement of the analagous result for the read-side critical section, available in Appendix \ref{sec:prooflemmas}.
%\begin{lemma}[Stable Environment Denotation-R]
%For any \emph{closed} environment $\Gamma$ (i.e., $\forall x\in\mathsf{dom}(\Gamma)\ldotp, \mathsf{FV}(\Gamma(x))\subseteq\mathsf{dom}(\Gamma)$):
%\[
%\mathcal{R}(\llbracket\Gamma\rrbracket_{\mathsf{R},tid})\subseteq\llbracket\Gamma\rrbracket_{\mathsf{R},tid}
%\]
%Alternatively, we say that environment denotation is \emph{stable} (closed under $\mathcal{R}$).
%\end{lemma}
%\begin{proof}
%In Appendix \ref{sec:prooflemmas} Lemma \ref{lem:stblRap}.
%\end{proof}

With this setup done, we we can state the connection between the Views Framework logic induced by earlier parameters, and the type system from Section \ref{sec:tslbl}.
The induced Views logic has a familiar notion of Hoare triple --- $\{ p \} C \{ q \}$ where $p$ and $q$ are elements of $\mathsf{View}_\mathcal{M}$ --- with the usual rules for non-deterministic choice, non-deterministic iteration, sequential composition, and parallel composition, sound given the proof obligations just described above.  It is parameterized by a rule for atomic commands that requires a specification of the triples for primitive operations, and their soundness (an obligation we must prove).  This can then be used to prove that every typing derivation embeds to a valid derivation in the Views Logic, roughly
$\forall\Gamma,C,\Gamma',\mathit{tid}\ldotp\Gamma\vdash C\dashv \Gamma' \Rightarrow \{\llbracket\Gamma\rrbracket_\mathit{tid}\} \llbracket C\rrbracket_\mathit{tid}\{\llbracket\Gamma'\rrbracket_\mathit{tid}\}$
once for the writer type system, once for the readers.

\begin{figure}[t]\scriptsize
$
\begin{array}{l}
\downarrow{\mathsf{if}\;(x.f==y)\;C_1\;C_2}\downarrow\mathit{tid} \overset{\mathrm{def}}{=} z=x.f;((\mathsf{assume}(z=y);C_1)+(\mathsf{assume}(z\neq y);C_2))
\end{array}
$
$
\llbracket\texttt{assume}(\mathcal{S})\rrbracket (s)\overset{\mathrm{def}}{=}\left\{
\begin{array}{ll}
\{ s\} & \textrm{if}~s \in \mathcal{S}\\
\emptyset & \textrm{Otherwise}
\end{array}
\right.
$
$
\downarrow{\mathsf{while}\;(e)\;C}\downarrow \overset{\mathrm{def}}{=} \left(\mathsf{assume}(e);C\right)^{*};(\mathsf{assume}(\lnot e ));
$
$
\inferrule
{
\{P\} \cap \{\lceil\mathcal{S} \rceil \}  \sqsubseteq \{Q\}
}
{
 \{P\} \texttt{assume}\left(\mathcal{S}\right)\{Q\}
}
$
\textsf{ where } $\lceil \mathcal{S} \rceil = \{m | \lfloor m \rfloor \cap \mathcal{S} \neq \emptyset \}
$
\caption{Encoding branch conditions with \textsf{assume}(b)}
\label{fig:asm}
\end{figure}

There are two remaining subtleties to address.  First,
commands $C$ also require translation: the Views Framework has only non-deterministic branches and loops, so the standard versions from our core language must be encoded.  The approach to this is based on a standard idea in verification, which we show here for conditionals as shown in Figure \ref{fig:asm}. $\textsf{assume}(b)$ is a standard idea in verification semantics~\cite{Barnett:2005:BMR:2090458.2090481,Muller:2016:VVI:2963187.2963190}, which ``does nothing'' (freezes) if the condition $b$ is false, so its postcondition in the Views logic can reflect the truth of $b$.  \textsf{assume} in Figure \ref{fig:asm} adapts this for the Views Framework as in other Views-based proofs~\cite{oopsla12,toplas17}, specifying sets of machine states as a predicate. We write boolean expressions as shorthand for the set of machine states making that expression true.  

Second, we have not addressed a way to encode subtyping.  One might hope this corresponds to a kind of implication, and therefore subtyping corresponds to consequence.  Indeed, this is how we (and prior work~\cite{oopsla12,toplas17}) address subtyping in a Views-based proof.
Views defines the notion of \emph{view shift}\footnote{This is the same notion present in later program logics like Iris~\cite{krebbers2017essence}, though more recent variants are more powerful.} ($\sqsubseteq$) as a way to reinterpret a set of instrumented states as a new (compatible) set of instrumented states, offering a kind of logical consequence, used in a rule of consequence in the Views logic:
\[ p \sqsubseteq q \stackrel{def}{=} \forall m\in\mathcal{M} \ldotp \lfloor p * \{ m \} \rfloor \subseteq \lfloor q* \mathcal{R}(\{m\})\rfloor\]

We are now finally ready to prove the key lemmas of the soundness proof, relating subtying to view shifts, proving soundness of the primitive actions, and finally for the full type system.  These proofs occur once for the writer type system, and once for the reader; we show here only the (more complex) writer obligations:

%We express the reinterpretation of $p$ as $q$ with action $\alpha$ ensuring that the operation interpretation of the action satisfies the specification:$ p \sqsubseteq q \stackrel{def}{=} \forall m\in\mathcal{M} \ldotp \lfloor p * \{ m \} \rfloor \subseteq \lfloor q* \mathcal{R}(\{m\})\rfloor$. Because the Views framework handles soundness for the structural rules (sequencing, parallel composition, etc.), there are really only three types of proof obligations for us to prove.  First, we must prove that the non-trivial command translations (i.e., for conditionals and while loops) embed correctly in the Views logic, which is straightforward.  Second, we must show that for our environment subtyping, if $\Gamma<:\Gamma'$, then $\llbracket{\Gamma}\rrbracket\sqsubseteq\llbracket\Gamma'\rrbracket$.  And finally, we must prove that each atomic action's type rule corresponds to a valid semantic judgment in the Views Framework:
%\[
%\forall m\ldotp   \llbracket \alpha \rrbracket ( \lfloor \llbracket \Gamma_{1} \rrbracket_{tid}  * \{m\} \rfloor) \subseteq
%  \lfloor \llbracket \Gamma_{2} \rrbracket_{tid} * \mathcal{R}(\{m\}) \rfloor
%  \]
%The use of $*$ validates the frame rule and makes this obligation akin to an interference-tolerant version of the small footprint property from traditional separation logics~\cite{Reynolds:2002:SLL:645683.664578,Calcagno:2007:LAA:1270399.1271718}.
\begin{lemma}[Axiom of Soundness for Atomic Commands]
  \label{lem:axmsoundness}
For each axiom, $\Gamma_{1} \vdash_{\textsf{M}} \alpha \dashv \Gamma_{2}$, we show
$
\forall m\ldotp   \llbracket \alpha \rrbracket  (\lfloor \llbracket \Gamma_{1} \rrbracket_{tid}  * \{m\} \rfloor )\subseteq  \lfloor \llbracket \Gamma_{2} \rrbracket_{tid} * \mathcal{R}(\{m\}) \rfloor
$
\end{lemma}
\begin{proof}
By case analysis on $\alpha$. Details in Appendix \ref{sec:prooflemmas}. % Lemma \ref{lem:axmsoundnessap}
\end{proof}
\begin{lemma}[Context-SubTyping-M]\label{lem:cntxsubt-mcln}
$ \Gamma \subt \Gamma'  \implies \llbracket \Gamma \rrbracket_{M,tid} \sqsubseteq \llbracket  \Gamma' \rrbracket_{M,tid} $
\end{lemma}
\begin{proof}
Induction on the subtyping derivation, then inducting on the single-type subtype relation for the first variable in the non-empty context case.
\end{proof}

%Type soundness proceeds according to the requirements of the Views Framework, primarily embedding each type judgment into the Views logic:
%\begin{lemma}[Views Embedding for Read-Side]
%  \label{lemma:embedr}
%\[  \forall\Gamma,C,\Gamma',\mathit{t}\ldotp\Gamma\vdash_R C\dashv \Gamma' \Rightarrow
%\llbracket\Gamma\rrbracket_\mathit{t}\cap\llbracket{R}\rrbracket_t\vdash \llbracket C\rrbracket_\mathit{t}\dashv\llbracket\Gamma'\rrbracket_\mathit{t}\cap\llbracket{R}\rrbracket_t
%\]
%\end{lemma}
%\begin{proof}
%In Appendix \ref{sec:prooflemmas} Lemma \ref{lemma:embedrap}.
%  \end{proof}
\begin{lemma}[Views Embedding for Write-Side]
  \label{lemma:embedw}
\\\mbox{$\qquad
\forall\Gamma,C,\Gamma',\mathit{t}\ldotp\Gamma\vdash_M C\dashv \Gamma' \Rightarrow
\llbracket\Gamma\rrbracket_\mathit{t}\cap\llbracket{M}\rrbracket_t\vdash \llbracket C\rrbracket_\mathit{t}\dashv\llbracket\Gamma'\rrbracket_\mathit{t}\cap\llbracket{M}\rrbracket_t
$}
\end{lemma}
\begin{proof}
By induction on the typing derivation, appealing to Lemma \ref{lem:axmsoundness} for primitives, Lemma \ref{lem:cntxsubt-mcln} and consequence for subtyping, and otherwise appealing to structural rules of the Views logic and inductive hypotheses.
Full details in Appendix \ref{sec:prooflemmas}. %Lemma \ref{lemma:embedwap}.
  \end{proof}

The corresponding obligations and proofs for the read-side critical section type system are similar in statement and proof approach, just for the read-side type judgments and environment denotations.
%Because the intersection of the environment denotation with the denotations for the different critical sections remains a valid view, the Views Framework provides most of this proof for free, given corresponding lemmas for the \emph{atomic actions} $\alpha$:
%\[\begin{array}{l}
%\forall \alpha,\Gamma_1,\Gamma_2\ldotp \Gamma_1\vdash_R\alpha\dashv\Gamma_2 \Rightarrow
%\\
%\quad\forall m\ldotp   \llbracket \alpha \rrbracket  (\lfloor \llbracket \Gamma_{1} \rrbracket_{\textsf{R},tid}  * \{m\} \rfloor )\subseteq  \lfloor \llbracket \Gamma_{2} \rrbracket_{\textsf{R},tid} * \mathcal{R}(\{m\}) \rfloor
%\end{array}\]
%\[
%\begin{array}{l}
%\forall \alpha,\Gamma_1,\Gamma_2\ldotp \Gamma_1\vdash_M\alpha\dashv\Gamma_2 \Rightarrow
%\\
%\quad\forall m\ldotp   \llbracket \alpha \rrbracket  (\lfloor \llbracket \Gamma_{1} \rrbracket_{\textsf{M},tid}  * \{m\} \rfloor )\subseteq  \lfloor \llbracket \Gamma_{2} \rrbracket_{\textsf{M},tid} * \mathcal{R}(\{m\}) \rfloor
%\end{array}
%\]
% \[
% \forall\Gamma,\alpha,\Gamma',\mathit{t}\ldotp\Gamma\vdash_R \alpha\dashv \Gamma' \Rightarrow
%     \llbracket\Gamma\rrbracket_\mathit{t}\cap\llbracket{R}\rrbracket_t\vdash \llbracket \alpha\rrbracket_\mathit{t}\dashv\llbracket\Gamma'\rrbracket_\mathit{t}\cap\llbracket{R}\rrbracket_t
% \]
% \[
% \forall\Gamma,\alpha,\Gamma',\mathit{t}\ldotp\Gamma\vdash_M \alpha\dashv \Gamma' \Rightarrow
%     \llbracket\Gamma\rrbracket_\mathit{t}\cap\llbracket{M}\rrbracket_t\vdash \llbracket \alpha\rrbracket_\mathit{t}\dashv\llbracket\Gamma'\rrbracket_\mathit{t}\cap\llbracket{M}\rrbracket_t
% \]
%$\alpha$ ranges over any atomic command, such as a field access or variable assignment.
%%%A number of rules in the formal system (Section \todo{ref}) are present in \emph{both} systems, and we would like to reuse their proofs.  To support this, we prove the following lemma, which permits us to ignore which critical section such rules are considered in, and lift that ``ignorant'' proof to either critical section:
%Denoting a type environment $\llbracket\Gamma\rrbracket_{\mathsf{M},tid}$, unfolding the definition one step, is merely $\llbracket\Gamma\rrbracket_{tid}\cap\llbracket\mathsf{M}\rrbracket_{tid}$.
%n the type system for write-side critical sections, this introduces extra boilerplate reasoning to prove that each action preserves lock ownership.  To simplify later cases of the proof, we first prove this convenient lemma.
%begin{lemma}[Write-Side Critical Section Lifting]
%label{lem:crit-lifting}
%or each $\alpha$ whose semantics does not affect the write lock, if
%[\forall m\ldotp   \llbracket \alpha \rrbracket  (\lfloor \llbracket \Gamma_{1} \rrbracket_{tid}  * \{m\} \rfloor )\subseteq  \lfloor \llbracket \Gamma_{2} \rrbracket_{tid} * \mathcal{R}(\{m\}) \rfloor\]
%hen
%%%\forall m\ldotp   \llbracket \alpha \rrbracket  (\lfloor \llbracket \Gamma_{1} \rrbracket_{\textsf{R},tid}  * \{m\} \rfloor )\subseteq  \lfloor \llbracket \Gamma_{2} \rrbracket_{\textsf{R},tid} * \mathcal{R}(\{m\}) \rfloor\]
%[\forall m\ldotp   \llbracket \alpha \rrbracket  (\lfloor \llbracket \Gamma_{1} \rrbracket_{\textsf{M},tid}  * \{m\} \rfloor )\subseteq  \lfloor \llbracket \Gamma_{2} \rrbracket_{\textsf{M},tid} * \mathcal{R}(\{m\}) \rfloor\]
%end{lemma}
%begin{proof}
%n Appendix \ref{sec:prooflemmas}.
%end{proof}
