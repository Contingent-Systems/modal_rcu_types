\section{Related Work}
\label{sec:relatedwork}
Our type system work builds on a great deal of related work on RCU implementations and models; and general concurrent program verification (via program logics, model checking, and type systems).

\mypar{Modeling RCU}
Alglave et al.~\cite{Alglave:2018:FSC:3173162.3177156} propose a memory model to be assumed by the platform-independent parts of the Linux kernel, regardless of the underlying hardware's memory model.
As part of this, they give the first formalization of what it means for an RCU implementation to be correct (previously this was difficult to state, as the guarantees in principle could vary by underlying CPU architecture). Essentially, that reader critical sections do not span grace periods. They prove by hand that the Linux kernel RCU implementation~\cite{DBLP:conf/cav/AlglaveKT13,abssem} satisfies this property. According to the definition of \textsf{RCU} ~\cite{abssem,Alglave:2018:FSC:3173162.3177156}, our model in Section \ref{sec:semantics} is a valid RCU implementation (assuming sequential consistency):
\begin{itemize}
  \item \textit{Grace-Period and Memory-Barrier Guarantee}: To reclaim a heap location, a mutator thread must synchronize with all of the reader threads with overlapping read-side critical sections to guarantee that none of the updates to the memory cause invalid memory accesses.
The operational semantics enforce a \textit{protocol} on the mutator thread's actions. First it unlinks a node from the data structure; the local type for that reference becomes \textsf{unlinked}. Then it waits for current reader threads to exit, after which the local type is \textsf{freeable}. Finally, it may safely reclaim the memory, after which the local type is \textsf{undef}.
The semantics prevent the writer from reclaiming too soon by adding the heap location to the free list of the state, which is checked dynamically by the actual free operation. We discuss the grace period and unlinking invariants in our system in Section \ref{sec:lemmas}.
\item \textit{Publish-Subscribe Guarantee}: Fresh heap nodes cannot be observed by the reader threads until they are published. As we see in the operational semantics, once a new heap location is allocated it can only be referenced by a local \textsf{fresh}. Once it is published, the local type for that reference becomes \textsf{rcuItr}; to put in other words, it is now safe for the reader thread to access it with local references in \textsf{rcuItr} type. We discuss the related type assertions for inserting/replacing(Figure \ref{fig:freshframeout}) a fresh node in Section \ref{subsection:type-rules} and the related invariants in Section \ref{sec:lemmas}.
\item \textit{RCU Primitives Guaranteed to Execute Unconditionally}: Uncoditional execution of RCU Primitives are provided by the definitions in our operational semantics for our RCU primitives(e.g. \lstinline|ReadBegin|, \lstinline|ReadEnd|, \lstinline|WriteBegin|, \lstinline|WriteEnd| and \lstinline|SyncStart;SyncStop|).
\item \textit{Guaranteed Read-to-Write Upgrade}: Our system provides a clear separation of \textit{traverse-and-update} and \textit{traverse-only} intentions for \textsf{RCU} programming through the type system together(e.g. different iterator types and rules for the write/read critical sections) with the programming primitives. 
  \end{itemize}
To the best of our knowledge, ours is the first abstract \emph{operational} model for a Linux kernel-style RCU implementation --- others are implementation-specific~\cite{Mandrykin:2016:TDV:3001219.3001297} or axiomatic like Alglave et al.'s.

\mypar{Realizing our RCU Model} Tassarotti et al. models a well-known way of implementing RCU synchronization without hurting readers' performance, \textsf{Quiescent State Based Reclamation}(QSBR)~\cite{urcu_ieee} where synchronization in between the writer thread and reader threads provided via per-thread counters. A direct implementation of our semantics would yield unacceptable performance, since both entering(\lstinline|ReadBegin|) and exiting(\lstinline|ReadEnd|) modify shared data structures for the \textit{bounding-threads} and \textit{readers} sets. A slight variation on our semantics would use a bounding set  that tracked such a snapshot of counts, and a vector of per-thread counts in place of the reader set. Blocking grace period completion until the snapshot was strictly older than all current reader counts would be more clearly equivalent to these implementations. Our current semantics are simpler than this alternative, while also equivalent. We also know that if we had this slight variation in our model then all actions(traverse and read a heap value) from a reader thread would \textit{reduce} to a single \textit{atomic} action: read of a data value. However, we do not prove the \textit{atomicity} of the readers actions within the scope of this paper.

\mypar{Program Logics} Fu et al.~\cite{shao_temp} extend Rely-Guarantee/Separation-Logic~\cite{vafeiadis07,Feng:2007:RCS:1762174.1762193,Feng:2009:LRR:1480881.1480922} with the \textit{past-tense} temporal operator to eliminate the need for using a history variable and lift the standard separation conjuction to assert over on execution histories. Gotsman et al.~\cite{Gotsman:2013:VCM:2450268.2450289} take assertions from temporal logic to separation logic~\cite{vafeiadis07} to capture the essence of epoch-based memory reclamation algorithms and have a simpler proof than what Fu et al. have~\cite{shao_temp} for Michael's non-blocking stack~\cite{Michael:2004:HPS:987524.987595} implementation under a sequentially consistent memory model.

\mypar{Batched-Deallocation} Gotsman et al.~\cite{Gotsman:2013:VCM:2450268.2450289} and Tassarotti et al.~\cite{verrcu} consider the existence of \textit{batched-deallocation}. There is a direct mapping between Gotsman et al.'s \textsf{detached} and \textsf{in\_sum} sets for hazard pointers model and our logical abstract \textit{free-list}. Although it seems straightforward to reify the \textit{free-list} to the \textsf{detached} set of hazard pointers for batched-deallocation, we find it a good future direction to investigate the applicability of our type system to arbitrary clients under different memory reclamation schemes~\cite{Wen:2018:IMR:3178487.3178488,Michael:2004:HPS:987524.987595,Mckenney:2004:EDD:1048173,UCAM-CL-TR-579}.
\colin{if it's straightforward, is it research? or is there more subtlety here?}

\mypar{Weak Memory Models} Tassarotti et al.~\cite{verrcu} uses a protocol based program logic based on separation and ghost variables called \textsf{GPS}~\cite{Turon:2014:GNW:2660193.2660243} to verify user-level \textsf{RCU} singly linked list under \emph{release-acquire} semantics, which is a weaker memory model than sequential-consistency. They require \textit{release-writes} and \textit{acquire-reads} to the QSRB counters for proper synchronization in between the mutator and the reader threads. This synchronization is exactly the only one that we enforce in the logical observations of the mutator thread: from \textsf{unlinked} to \textsf{freeable}. Tassarotti et al.'s synchronization for linking/publishing a new node is also captured by our logical \textsf{fresh} observation. Based on these observations, we find it as an important future direction to investigate our type system formally with respect to these \textit{acquire-release} relations.

\mypar{Reusability of Predicates for Arbitrary Client Verification} We think that reusability of predicates used in arbitrary client verification is important. In this regard, Tassarotti et al.'s \textit{abstract-predicates} -- e.g. WriterSafe -- might not be easy to reuse for an arbitrary RCU client -- e.g. binary search tree -- as they include linked list specific logical constructions together with the constructions for QSRB model. Unlike, we use similar types both for BST(Appendix \ref{appendix:bst_del}) and linked-list based bag example.
%
%\mypar{Model Checking}
%Desnoyers et al. propose a virtual architecture to model out of order memory accesses and instruction scheduling~\cite{Desnoyers:2013:MSM:2506164.2506174} and use the \textsf{SPIN} model checker to verify a user-mode implementation of RCU~\cite{urcu_ieee}. This method requires manual translation from C to SPIN modelling language.
%Liang et al. presents an approach to verify the \emph{grace period} guarantee of \textsf{Tree RCU} in Linux kernel~\cite{LiangMKM16}. \textsf{Tree RCU} is an hieararchical \textsf{RCU} model which is a remedy to contention of writer threads in the single global lock model. 
%Similarly, Kokologiannakis et al.~\cite{Kokologiannakis:2017:SMC:3092282.3092287} use a stateless model checker for testing the core of \textsf{Tree RCU}.
%Liang's approach has limited support for lists and callback handling which are important when we consider the correctness for writer primitives which are based on callback handling. Kokologiannakis's approach overcomes all these limitations and shows considerable performance when compared with Liang's approach using \textsf{CBMC}. 
%Both focus on validating a particular RCU implementation, whereas we focus on verifying memory safety of clients independent of implementation.
 
%\mypar{Type Systems}
%Howard et al.~\cite{Howard:2011:RES:2001252.2001267} enhance \textsf{STM} in Haskell to a technique called \textit{Relativistic Programming} which aims low overhead linearly scalable concurrent threads. Unlike our system which types binary search tree in \textsf{RCU} setting, they claim  handling trees (look-up followed by update) as a future work.
%A follow up paper from Cooper et al.~\cite{Cooper2015RelativisticPI} presents a \textsf{Haskell} library called \emph{Monadic RP}, for relativistic programming. Similar to our approach, Monadic RP provides types and relativistic programming constructs for write/read critical sections which enforce correct usage of relativistic programming pattern. 
%They also have only checked a linked list.
%Thus our work is the first type system for ensuring correct use of RCU primitives that is known to handle more complex structures than linked lists.
\section{Conclusions}
\label{sec:concls}
