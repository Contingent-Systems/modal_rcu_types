\section{Discussion \& Related Work}
\label{sec:relatedwork}
Our type system builds on a great deal of related work on RCU implementations and models; and general concurrent program verification. Due to space limit, this section captures only discussions on program logics, modeling RCU and memory models, but our technical report~\cite{isotek} includes detailed discussions on model-checking~\cite{Kokologiannakis:2017:SMC:3092282.3092287,LiangMKM16,urcu_ieee}, language oriented approaches~\cite{Howard:2011:RES:2001252.2001267,Cooper2015RelativisticPI,Howard:2011:RES:2001252.2001267} and realization of our semantics in an implementation as well.

\mypar{Modeling RCU and Memory Models}
Alglave et al.~\cite{Alglave:2018:FSC:3173162.3177156} propose a memory model to be assumed by the platform-independent parts of the Linux kernel, regardless of the underlying hardware's memory model.
As part of this, they give the first formalization of what it means for an RCU implementation to be correct (previously this was difficult to state, as the guarantees in principle could vary by underlying CPU architecture). Essentially, reader critical sections must not span grace periods. They prove by hand that the Linux kernel RCU implementation~\cite{DBLP:conf/cav/AlglaveKT13} satisfies this property. McKenney has defined fundamental requirements of \textsf{RCU} implementations~\cite{abssem}; our model in Section \ref{sec:semantics} is a valid RCU implementation according to those requirements (assuming sequential consistency) aside from one performance optimization, \textit{Read-to-Write Upgrade}, which is important in practice but not memory-safety centric -- see the technical report~\cite{isotek} for detailed discussion on satisfying RCU requirements. To the best of our knowledge, ours is the first abstract \emph{operational} model for a Linux kernel-style RCU implementation -- others are implementation-specific~\cite{Mandrykin:2016:TDV:3001219.3001297} or axiomatic like Alglave et al.'s.

Tassarotti et al. model a well-known way of implementing RCU synchronization without hurting readers' performance --- \textsf{Quiescent State Based Reclamation} (QSBR)~\cite{urcu_ieee} --- where synchronization between the writer thread and reader threads occurs via per-thread counters. Tassarotti et al.~\cite{verrcu} uses a protocol based program logic based on separation and ghost variables called \textsf{GPS}~\cite{Turon:2014:GNW:2660193.2660243} to verify a user-level implementation of \textsf{RCU} with a singly linked list client under \emph{release-acquire} semantics, which is a weaker memory model than sequential-consistency. Despite the weaker model, the protocol that they enforce on their RCU primitives is nearly the same what our type system requires. The reads and writes to per thread QSBR structures are similar to our more abstract updates to reader and bounding sets. Therefore, we anticipate it would be possible to extend our type system in the future for similar weak memory models.%To be more specific, as a part of their synchronization protocol, the writer updates its own counter to assert the fact that a node has been made unreachable, and a request for permission to deallocate the node has been made. On the other hand, a reader updates its own counters to the value of the writer's counter to give up its own permission to access the unlinked -- which is unreachable -- node so that the writer can deallocate it. Tassarotti et al.'s final \emph{release-acquire} synchronization for linking/publishing new nodes occurs in a similar way to ours. So, based on the similarities of the facts that both all these three \emph{release-acquire} pairs and our abstract semantics together with abstract invariants capture, we anticipate it would be possible to extend our type system in the future for similar weak memory models.

\mypar{Program Logics} Fu et al.~\cite{shao_temp} extend Rely-Guarantee and Separation-Logic~\cite{vafeiadis07,Feng:2007:RCS:1762174.1762193,Feng:2009:LRR:1480881.1480922} with the \textit{past-tense} temporal operator to eliminate the need for using a history variable and lift the standard separation conjunction to assert over on execution histories. Gotsman et al.~\cite{Gotsman:2013:VCM:2450268.2450289} take assertions from temporal logic to separation logic~\cite{vafeiadis07} to capture the essence of epoch-based memory reclamation algorithms and have a simpler proof than what Fu et al. have~\cite{shao_temp} for Michael's non-blocking stack~\cite{Michael:2004:HPS:987524.987595} implementation under a sequentially consistent memory model.

Tassarotti et al.~\cite{verrcu} use \textit{abstract-predicates} -- e.g. WriterSafe -- that are specialized to the singly-linked structure in their evaluation.  This means reusing their ideas for another structure, such as a binary search tree, would require revising many of their invariants.  By contrast, our types carry similar information (our denotations are similar to their definitions), but are reusable across at least singly-linked and tree data structures (Section \ref{sec:eval}). 
Their proofs of a linked list also require managing assertions about RCU implementation resources, while these are effectively hidden in the type denotations in our system.
On the other hand, their proofs ensure full functional correctness.  Meyer and Wolff~\cite{myr} make a compelling argument that separating memory safety from correctness if profitable, and we provide such a decoupled memory safety argument. 
\section{Conclusions}
\label{sec:concls}
We presented the first type system that ensures code uses RCU memory management safely, and which is significantly simpler than full-blown verification logics. To this end, we gave the first general operational model for RCU-based memory management. Based on our suitable abstractions for RCU in the operational semantics we are the first showing that decoupling the \textit{memory-safety} proofs of RCU clients from the underlying reclamation model is possible. Meyer et al.~\cite{myr} took similar approach for decoupling the \textit{correctness} verification of the data structures from the underlying reclamation model under the assumption of the \textit{memory-safety} for the data structures. We demonstrated the applicability/reusability of our types on two examples: a linked-list based bag~\cite{McKenney2015SomeEO} and a binary search tree~\cite{Arbel:2014:CUR:2611462.2611471}. To our best knowledge, we are the first presenting the \textit{memory-safety} proof for a tree client of RCU. We managed to prove type soundness by embedding the type system into an abstract concurrent separation logic called the Views Framework~\cite{views} and encode many RCU properties as either type-denotations or global invariants over abstract RCU state. By doing this, we managed to discharge these invariants once as a part of soundness proof and did not need to prove them for each different client.
\paragraph{}
\mypar{Acknowledgements.} We are grateful to Matthew Parkinson for guidance and productive discussions on the early phase of this project. We also thank to Nik Sultana and Klaus V. Gleissenthall for their helpful comments and suggestions for improving the paper.
