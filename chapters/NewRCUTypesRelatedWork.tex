\section{Related Work}
\label{sec:relatedwork}
Our type system builds on a great deal of related work on RCU implementations and models; and general concurrent program verification (via program logics, model checking, and type systems).

\mypar{Modeling RCU and Memory Models}
Alglave et al.~\cite{Alglave:2018:FSC:3173162.3177156} propose a memory model to be assumed by the platform-independent parts of the Linux kernel, regardless of the underlying hardware's memory model.
As part of this, they give the first formalization of what it means for an RCU implementation to be correct (previously this was difficult to state, as the guarantees in principle could vary by underlying CPU architecture). Essentially, that reader critical sections do not span grace periods. They prove by hand that the Linux kernel RCU implementation~\cite{DBLP:conf/cav/AlglaveKT13} satisfies this property. According to the fundamental requirements of \textsf{RCU} ~\cite{abssem}, our model in Section \ref{sec:semantics} can be considered as a valid RCU implementation satisfying all requirements for an RCU implementation(assuming sequential consistency) aside from one performance optimization, \textit{Read-to-Write Upgrade}, which is important in practice but not memory-safety centric:
\begin{itemize}
  \item \textit{Grace-Period and Memory-Barrier Guarantee}: To reclaim a heap location, a mutator thread must synchronize with all of the reader threads with overlapping read-side critical sections to guarantee that none of the updates to the memory cause invalid memory accesses.
The operational semantics enforce a \textit{protocol} on the mutator thread's actions. First it unlinks a node from the data structure; the local type for that reference becomes \textsf{unlinked}. Then it waits for current reader threads to exit, after which the local type is \textsf{freeable}. Finally, it may safely reclaim the memory, after which the local type is \textsf{undef}.
The semantics prevent the writer from reclaiming too soon by adding the heap location to the free list of the state, which is checked dynamically by the actual free operation. We discuss the grace period and unlinking invariants in our system in Section \ref{sec:lemmas}.
\item \textit{Publish-Subscribe Guarantee}: Fresh heap nodes cannot be observed by the reader threads until they are published. As we see in the operational semantics, once a new heap location is allocated it can only be referenced by a local variable of type \textsf{fresh}. Once published, the local type for that reference becomes \textsf{rcuItr}, indicating it is now safe for the reader thread to access it with local references in \textsf{rcuItr} type. We discuss the related type assertions for inserting/replacing(Figures \ref{fig:frframeout}-\ref{fig:freshframeout}) a fresh node in Section \ref{subsection:type-rules} and the related invariants in Section \ref{sec:lemmas}.
\item \textit{RCU Primitives Guaranteed to Execute Unconditionally}: Unconditional execution of RCU Primitives are provided by the definitions in our operational semantics for our RCU primitives(e.g. \lstinline|ReadBegin|, \lstinline|ReadEnd|, \lstinline|WriteBegin| and \lstinline|WriteEnd|) as their executions do not consider failure/retry.
\item \textit{Guaranteed Read-to-Write Upgrade}: This is a performance optimization which allows the reader threads to upgrade the read-side critical section to the write-critical section by acquiring the lock after a traversal for a data element and ensures that the upgrading-reader thread exit the read-critical section before calling RCU synchronization. This optimization also allows sharing the traversal code between the critical sections. \textit{Read-to-Write} is an important optimization in practice but largely orthogonal to memory-safety. Current version of our system provides a strict separation of \textit{traverse-and-update} and \textit{traverse-only} intentions through the type system(e.g. different iterator types and rules for the RCU Write/Read critical sections) and the programming primitives. As a future work, we want to extend our system to support this performance optimization.
  \end{itemize}
To the best of our knowledge, ours is the first abstract \emph{operational} model for a Linux kernel-style RCU implementation -- others are implementation-specific~\cite{Mandrykin:2016:TDV:3001219.3001297} or axiomatic like Alglave et al.'s.

Tassarotti et al. model a well-known way of implementing RCU synchronization without hurting readers' performance, \textsf{Quiescent State Based Reclamation}(QSBR)~\cite{urcu_ieee} where synchronization between the writer thread and reader threads provided via per-thread counters. Tassarotti et al.~\cite{verrcu} uses a protocol based program logic based on separation and ghost variables called \textsf{GPS}~\cite{Turon:2014:GNW:2660193.2660243} to verify a user-level implementation of \textsf{RCU} with a singly linked list client under \emph{release-acquire} semantics, which is a weaker memory model than sequential-consistency. They require \textit{release-writes} and \textit{acquire-reads} to the QSRB counters for proper synchronization in between the mutator and the reader threads. This protocol is exactly what we enforce over the logical observations of the mutator thread: from \textsf{unlinked} to \textsf{freeable}. 
Tassarotti et al.'s synchronization for linking/publishing new nodes occurs in a similar way to ours, so we anticipate it would be possible to extend our type system in the future for similar weak memory models.

\mypar{Program Logics} Fu et al.~\cite{shao_temp} extend Rely-Guarantee and Separation-Logic~\cite{vafeiadis07,Feng:2007:RCS:1762174.1762193,Feng:2009:LRR:1480881.1480922} with the \textit{past-tense} temporal operator to eliminate the need for using a history variable and lift the standard separation conjunction to assert over on execution histories. Gotsman et al.~\cite{Gotsman:2013:VCM:2450268.2450289} take assertions from temporal logic to separation logic~\cite{vafeiadis07} to capture the essence of epoch-based memory reclamation algorithms and have a simpler proof than what Fu et al. have~\cite{shao_temp} for Michael's non-blocking stack~\cite{Michael:2004:HPS:987524.987595} implementation under a sequentially consistent memory model.

Tassarotti et al.~\cite{verrcu} use \textit{abstract-predicates} -- e.g. WriterSafe -- that are specialized to the singly-linked structure in their evaluation.  This means reusing their ideas for another structure, such as a binary search tree, would require revising many of their invariants.  By contrast, our types carry similar information (our denotations are similar to their definitions), but are reusable across at least singly-linked and tree data structures (Section \ref{sec:eval}). 
Their proofs of a linked list also require managing assertions about RCU implementation resources, while these are effectively hidden in the type denotations in our system.
On the other hand, their proofs ensure full functional correctness.  Meyer and Wolff~\cite{myr} make a compelling argument that separating memory safety from correctness if profitable, and we provide such a decoupled memory safety argument. 

\mypar{Realizing our RCU Model} A direct implementation of our semantics would yield unacceptable performance, since both entering (\lstinline|ReadBegin|) and exiting (\lstinline|ReadEnd|) modify shared data structures for the \textit{bounding-threads} and \textit{readers} sets. A slight variation on our semantics would use a bounding set  that tracked such a snapshot of counts, and a vector of per-thread counts in place of the reader set. Blocking grace period completion until the snapshot was strictly older than all current reader counts would be more clearly equivalent to these implementations. Our current semantics are simpler than this alternative, while also equivalent. 
%We also know that if we had this slight variation in our model then all actions (traversal and reads) from a reader thread would \textit{reduce} to a single \textit{atomic} action: read of a data value. However, we do not prove the \textit{atomicity} of the readers actions within the scope of this paper.
%%% NOTE: this is actually false in general: since the readers can still see changes to the structure by the writer, it's possible for their executions to be non-linearizable; if they're doing something like least element greater than foo in a binary tree, concurrent writer modifications can yield lookup results you wouldn't see in a serialized execution.

\mypar{Model Checking} Kokologiannakis et al.~\cite{Kokologiannakis:2017:SMC:3092282.3092287} use model-checking to test the core of \textsf{Tree RCU} in Linux kernel. Liang et al.~\cite{LiangMKM16} use model-checking to verify the \emph{grace period} guarantee of \textsf{Tree RCU}. Both focus on validating a particular RCU implementation, whereas we focus on verifying memory safety of clients independent of implementation. Desnoyers et al.~\cite{urcu_ieee} use the \textsf{SPIN} model checker to verify a user-mode implementation of RCU and this requires manual translation from C to SPIN modeling language.
In addition to being implementation-specific, they require test harness code, validating its behavior rather than real client code.

\mypar{Type Systems}
Howard et al.~\cite{Howard:2011:RES:2001252.2001267,Cooper2015RelativisticPI} present a \textsf{Haskell} library called \emph{Monadic RP} which provides types and relativistic programming constructs for write/read critical sections which enforce correct usage of relativistic programming pattern. They also have only checked a linked list. They claim  handling trees (look-up followed by update) as a future work~\cite{Howard:2011:RES:2001252.2001267}. Thus our work is the first type system for ensuring correct use of RCU primitives that is known to handle more complex structures than linked lists.
\section{Conclusions}
\label{sec:concls}
We presented the first type system that ensures code uses RCU memory management safely, and which which is significantly simpler than full-blown verification logics. To this end, we gave the first general operational model for RCU-based memory management. Based on our suitable abstractions for RCU in the operational semantics we are the first showing that decoupling the \textit{memory-safety} proofs of RCU clients from the underlying reclamation model is possible. Meyer et al.~\cite{myr} took similar approach for decoupling the \textit{correctness} verification of the data structures from the underlying reclamation model under the assumption of the \textit{memory-safety} for the data structures. We demonstrated the applicability/reusability of our types on two examples: a linked-list based bag~\cite{McKenney2015SomeEO} and a binary search tree~\cite{Arbel:2014:CUR:2611462.2611471}. To our best knowledge, we are the first presenting the \textit{memory-safety} proof for a tree client of RCU. We managed to prove type soundness by embedding the type system into an abstract concurrent separation logic called the Views Framework~\cite{views} and encode many RCU properties as either type-denotations or global invariants over abstract RCU state. By doing this, we managed to discharge these invariants once as a part of soundness proof and did not need to prove them for each different client.
