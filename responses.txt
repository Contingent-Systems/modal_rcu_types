We graciously thank the reviewers for their careful attention and feedback.
The results presented in this paper involve a novel reasoning principle for non-trivial RCU clients,
and we will take into consideration the reviewers' remarks concerning the presentation.

##Issue0: Introduction of the Invariants - Reviewer 1 -:
 * We can introduce the informal invariants --current Section 6.1-- after introducing the logical state before the set M in page 19 introduced in Section 6.2.

##Issue1: Clarifying Replacement/Insertion and Figure 7 - Reviewer 1 -:
 * Instead of referring to the specific type rule names at page 10, we can refer them in a more general way.
 
 * We refer to Hoare-style in Section 4.2 to guide reading the type rules in Figure 6 and their application on linked-list(Figure 1) in pre/post-condition style.
 
 * We agree that the caption of Figure 7 does not distinguish "inserting" and "replacing" a node clearly, we have to make it clear.
 
 * We chose Figure 7 to represent T-Replace(not T-Insert) which we use in BST-Delete. We replace an existing node -- H1 -- with a fresh one -- Hf. "o" in T-Replace is "cr" in Figure 7.

 * Insertion of a new node(no replacement with an existing node) is typed with T-Insert. A fresh node can be linked via using a single field, meaning that
   the path to the "o" in T-Insert can be extended with a single field, and the rest of the fields has to point nulls for preventing memory leakage. Corner-cases are in the paper.
   
 * "H"s are heap nodes and circles are local references of the writer thread. To preserve unique reachability H5, H6 has to be framed-out. Any type of aliases for cr
   * Field mapping aliases a6:rcuItr\rhoN[l->cr]
   * Path alias a1 has the same type with cr before unlinking
     will be invalid after unlinking as cr becomes unlinked.

##Issue2: RCU Requirements - Reviewers 1,2-:
 * "Guaranteed ReadToWrite Upgrade" is a performance optimization lifting readers to register for becoming a writer thread after a long traversal,
    not directly related to ensuring memory safety as other requirements do. We haven't seen any RCU client benefits from this optimization(https://github.com/urcu),
    and this was even not a part of the fundamental requirements in early designs(https://lwn.net/Articles/262464/).
    
 * We can make "Unconditional Execution Of RCU Primitives" with a footnote.

##Issue3: Complexity. Reusable Type Assertions. Abstract Invariants. Automation/Decidability- Reviewers 1,2,3:
 * To address Reviewer 2's comment on Section 5, we would like to point out the comparison of our work with Tassarotti's logic[34] briefly in Related-Work.
 * We can reuse our abstract invariants for different tree-like data-structures. However, Tassarotti's logic requires you to rewrite the many of the linked-list invariants for arbitrary data structures.
   
 * We are not concerned with decidability in this paper. However, as Reviewer 1 mentions, this paper is about reasoning principles.
 
 * In aligned with decidability, reviewers 2 and 3 raise an important point about inferring the framing conditions which is the main source of the complexity in the type rules.
   But, we find this issue very important to investigate as future work.

##Issue4: Sync. Grammar for Atoms- Reviewers 2,3 -:
 * SyncStartSyncStop is confusing in Figure 1 and has to be replaced by Sync because Sync is a conceptual construct and can be thought as one action.
   We split it into two as Views considers only atoms in operational semantics -- Grammar for atoms include Sync.
   
 * The usage of "skip" in null map leads to having "skip" both as value and atom, we will fix it.

##Issue5: Correctness Argument for Subsequent Deallocation. RCURead-RCUWrite. Reusing Pointers. - Reviewer 2,3:
 * Reaching from rcuItr to unlinked and finally freeable is linear(not permitting multiple reclamations)
 * ToRCUWrite rule asserts the non-existence of references leaking memory when mutator exist
 * Reusing pointers:[Talk with Colin]

##Issue6: Grammar of \rho. Clarification/Quantification of "k" in Subtyping. Type Grammar - Reviewer 2:
 * Since grammar at page7 includes types for the write critical section, M, and "rcuItr" belongs to the read critical section, we don't skip it in the grammar at page7. 
 * [Colin Help] on arguing "k" and grammar for path etc.

##Issue7: Correctness Argument for Delayed Ownership Transfer - Reviewer 2-: [Colin Help]

##Issue8: Application of Rules in Section 3 to a Whole Program - Reviewer 2-: We, as Meyer and Wolf[29], have a very intuitive abstract operational semantics which provides pretty much sequential reasoning for the global state, so we think that an application of the operational semantic rules on a program wouldn't be much interesting to show.

##Issue9: Refining Types for Language Constructs - Reviewer 2 -:  
 * There exist duplicates in our type rules for control flows and mutations. However, we can type all possible heap mutation actions.
 * There is a bound on control-flow decisions and traversals in tree-like data structures are almost based on field access which our system already captures.




