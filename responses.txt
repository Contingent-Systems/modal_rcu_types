We graciously thank the reviewers for their careful attention and feedback. The results presented in this paper involve a novel memory safety reasoning principle for non-trivial RCU clients, and we will take into consideration the reviewers' remarks concerning the presentation. If the paper gets accepted, [ASK Colin].
##Issue0: Introduction of the Invariants - Reviewer A -: We can introduce the informal invariants --current Section 6.1-- after introducing the logical state before the set M in page 19 introduced in Section 6.2.

##Issue1: Clarifying Replacement/Insertion and Figure 7 - Reviewer A -:
 * Instead of refering to the specific type rule names at page 10, we can refer them in more general way.
 
 * We refer to Hoare-Style in Section 4.2 to guide reading the type rules in Figure 6 and their application on linked-list(Figure 1) in pre/post-condition style.
 
 * We agree that the caption of Figure 7 does not distinguish "inserting" and "replacing" a node clearly, we have to change it.
 
 * Replacing a node means we replace an existing node -- H1 -- with a fresh one -- Hf -- in Figure 7. We chose to put the figure of framing for T-Replace
   because we replace a heap node in typing BST-delete, so it does not quiter represent T-Insert, so "o" in T-Replace is "cr" in Figure 7.

   Insertion of a new node does no replacement with any existing one. T-Insert would have a simpler and similar figure. A fresh node can be linked via using a single field, meaning that
   path to the "o" in T-Insert can be extended with a single field, and rest of the fields has to point null for not leaking memory. Other corner-cases are mentioned in the paper.
   
 * To preserve unique reachability H5 has to be framed-out.
   Similary, there cannot be H6, meaning that there cannot be any field access to "cr"  we need framing out the H6 referenced by "a6" -- ("y" is "a6" \neq "o" is "cr") in T-Replace --
   to prevent any object field from any other context pointing to the unlinked node. This is crucial regarding soundness
   because all the object field mappings -- l->cr -- from any context -- y:rcuItr.\rho.N[l->cr] -- refer to an valid heap node -- where "cr" is now referencing to an unlinked node.
   It is important to note that ensuring non-existence of H6 is also a part of unique reachability. We agree with reviewer A that representing H6 and H5 make Figure 7 look more complicated than
   actually it is.
   Regarding path aliases, "a0" and "a1", as we show in the paper, "a1" refers to H1 --  a1:rcuItr \rho N[r->lm, l->crl] -- but unlinking H1 makes "a1" invalid as an alias of cr:unlinked.


##Issue3:RCU Requirements - Reviewers A,B-:
 * "Guaranteed Read-to-Write Upgrade" is a performance optimization lifting readers to register for becoming a writer thread after a long traversal,
    not directly related to ensuring memory safety as other 3examples. We haven't seen any RCU client benefiting from this optimization.
    
 *"Unconditional Execution of RCU Primitives" [Ask Colin].

##Issue4: Complexity. Reusable Type Assertions. Abstract Invariants . Automation/Decidability- Reviewers B,c:
 * As reviewer B mentions raises an important point on Section 5 and raise this compare our work with Tassarotti's RCU-logic briefly in Related Work.
   Our invariants are abstract so that we can reuse our assertions for different tree-like data-structures.
   On the other hand, you have to come up with different revise/rewrite the invariants for different datas when using Tassarotti's RCU logic.
   
 * Yes, our system is not decidable. As Reviewer A mentions this paper is about reasoning principles and we are not concerned with decidability.
 
 * In aligned with decidability, reviewers B and C raise an important point about inferring the framing conditions which introduces complexity to the type rules.
   But, we find this issue very important to investigate as a future work.

##Issue5:Correctness Argument for Delayed Ownership Transfer/Subsequent Deallocation. Reusing Pointers. - Reviewers B,C: [TODO]
 * not permitting multiple reclamation, careless wording not prove liveness if the critical section completes after the critical section. if it completes critical section. Point to the rule. Freeable is linear, no drop etc.
 *
 *
 *
##Issue6: Sync. RCURead-RCUWrite. Grammar for Atoms- Reviewers B,C -:
 * Clarification on Sync: SyncStart;SyncStop is confusing in Figure 1 is confusing and has to be replaced by one Sync because Sync is a conceptual construct and can be thought as one action.
   We split it into two as Views considers only atoms in operational semantics -- Grammar for atoms include Sync.
   
 * The usage of "skip" in nullmap leads to having "skip" both as value and atom, we will fix it.

##Issue7: Syntax/Grammar for \rho - Existential Quantification in Subtyping - Clarification on k - Reviewer B: [Colin Help] 

##Common Issue-8: Application of Rules to whole program does not exist - 

##Issue11: Refining Types for Language Constructs - Reviewer B -:  
 * Yes there seems to be some duplicates in our type-rules for control flows and mutations. However, we capture typing all possible heap mutation actions.
   Moreover, there is a bound on control flow decisions and we already have enough for  heap choice etc.[TODO]

