We thank the reviewers for their careful attention and feedback. We will take into consideration all of your comments about the presentation when we revise the paper.

> R1: Presentation 
Thanks for pointing out the detailed presentation issues. We have early versions which capture many those, but we will consider binding T-Replace to Figure 7, the introduction of invariants after the logical state in Section 6.2 carefully.

    
> R2: Emphasis on not appealing to implementation details 


We can make this clearer earlier, some comparisons to Tassarotti et al.'s program logic [34] can be found in p.24. We want to emphasize that there exists no clean separation between RCU primitive and linked-list specifications as their RCU primitives are linked-list dependent.


> All reviewers: Concerns about complexity, decidability, automation


Our focus in this paper, as Reviewer 1 noted, is the core reasoning principles where we chose a type system to focus on articulating those principles. As well-stated by Reviewer 2: this type system should be general enough to capture interesting programs, and likely requires less knowledge of advanced logical concepts to apply than e.g., an Iris-based logic.


Like Reviewer 2, we suspect the system is currently undecidable.  As reviewer 3 intuits,
while type checking the list and tree we found the choice of which rule to apply relatively straightforward, and the bookkeeping for the rules mostly tedious; so we are optimistic that *effective* automation is possible, but certainly future work.  We will be more explicit about this.


> R2&R3: Decomposition of Sync, RCUWrite/Begin.


As Reviewer 2 and Reviewer 3 pointed out, there are semantically misleading typos (ex: wrong brackets [|, missing y =x.f;C) in Figure 2 in desugaring, we will fix them. 


The Views Framework allows convenient use of only single-step *atomic* primitives.  Decomposing Sync into SyncStart and SyncStop is therefore required for our proof because the synchronization involves two steps: book-keeping, then waiting. Client programs would always execute both, together, without intervening local actions.




> R2&R3: Interactions between critical sections and non-critical-section code


The type system ensures unlinked and freeable references are handled *linearly*, as they cannot be dropped (coerced to undef). The top-level rule ToRCUWrite does ensure unlinked references have been freed, by forbidding them in the critical section's post-type-environment, as Reviewer 3 noticed. Preventing the reuse of rcuItr references across critical sections is subtler: the non-critical section system is *not* flow-sensitive, and does not include rcuItr.  So the initial environment lacks rcuItr, and "trailing" rcuItr may not escape.


> R2: Clarification/Quantification of "k" in Subtyping.


The k representing existentially-quantified finite path repetition is implicitly quantified at the
full context level so different paths can be related, as you noticed, and therefore does not
interact with the subtyping judgment.  We can and should make this more explicit.


> R2: Delayed Ownership Transfer


We can expand on this in Section 6.1: Once an object is observed as *unlinked* by the writer in the *observation-map* of the logical state, it waits for all other threadsâ€™ mappings to *iterator* observation dropped (object is mapped to *freeable* for the writer), and reclaim it.




> R2: Refining Rules for Language Constructs 


We do have multiple type rules for many language constructs. However, the growth in these is
bounded:


- Any control flow construct can be used to distinguish field contents, and therefore paths; so
  these rules each require some rule to reflect those distinctions into types: one field-refining rule per control flow construct, along with one general rule.
- We have all the heap mutation rules we would need for a larger language: one per conceptual
  update (linking fresh, replacing, or simply unlinking a node)



