One well-known way of implementing RCU synchronization without hurting readers performance is \textsf{Quiescent State Based Reclamation}(QSBR) ~\cite{urcu_ieee}. In QSBR model, the writer thread and each reader thread have their own counters. Tassarotti uses \textsf{iGPS} to verify a RCU linked list under \textit{Release-Acquire} semantics ~\cite{verrcu} against. In this section we take Tassarotti's approach as a reference to understand and explain our approach with respect to the following aspects in a comparative fashion.

\mypar{RCU Model} Tassarotti et al. ~\cite{verrcu} formalizes the crucial synchronization points in QSBR via the following relations.
\paragraph{Release-Acquire-1} defines the order imposed by the writer thread's release write and the reader threads' acquire reads. It makes sure that an initialization of an object field precedes the reader threads accesses.

There are two important actions which can perform updates on a field of an object: linking a fresh node by replacing existing one or unlinking an existing node. We should also note that all predicates in our model refer to the \textit{observations} made by the threads. Once the write thread updates an object field, its observation by the mutator thread changes: 1- unlinking changes the observation from \textsf{iterator} to \textsf{unlinked} 2- replacing a fresh node with an existing one changes the replaced node's observation from \textsf{iterator} to \textsf{unlinked} and linked node's observation from \textsf{fresh} to \textsf{iterator}. 

We wonder whether we would be able to claim the invariant -- \textit{"Readers always observe the heap as} \textsf{iterator}\textit{"} -- in the non-existence of the ordering imposed by \textit{Release-Acquire-1}. Yes, we would be able to claim the invariant because change in the observation of the writer thread does not affect the observations of the reader threads -- they are still \textsf{iterator}. However, the reader threads observing a heap node which is observed as \textsf{unlinked} by the writer thread are going to be in the set of \textit{bounding-threads} for the heap node to be reclaimed by the mutator thread.
\paragraph{Release-Acquire-2} defines the start of RCU synchronization. The writer thread increments its own counter to begin RCU synchronization. By doing so the writer thread announces the fact that the old node is now unreachable and going to be allocated. Then it reads the readers' counters until they match updated counter value.

The order imposed by \textit{Release-Acquire-2} is essential for our model as well because the writer thread and the reader threads have to synchronize for safe reclamation invariant: \textit{"There exists no} \textsf{iterator} \textit{observation on a heap node that is observed as} \textsf{unlinked} \textit{by the mutator thread"}. In our model, syncronization starts with setting the reader threads as \textit{bounding-threads}(has to be an synchronous update on a part of global shared state). In fact the first part of the invariant refers to these \textit{bounding-threads} as they observe the unlinked heap node as \textsf{iterator}.

Most crucial and obvious need for synchronizing the reader threads with the writer for a heap reclamation shows up in binary search tree \textit{node-delete} operation where the deleted node has more than one child. In this setting the writer thread first find the successor of the node to be deleted and then allocate a fresh node as a copy of the successor node. Now there are two heap updates to be occured in the same write-critical section: 1- Replace the node to be deleted with the fresh node with successor's data value 2- Delete the old successor. In this setting, the availability of the successor has to be ensured for the concurrent readers of the successor node. To do so, after executing step 1, the writer threads \textit{starts synchronization with the concurrent readers then removes the old succesoor}. During the delete operation the reader threads which start searching for the successor's data value \textit{before} the writer thread \textit{starts synchronization} find the successor in its previous location. The ones that start seaching after the \textit{after} synchronization find the new copy of the successor -- having two copies of the same value temporarily is called \textit{weak-bst} property ~\cite{Arbel:2014:CUR:2611462.2611471}.
\paragraph{Release-Acquire-3} defines the relation of \textit{quiescent} state for the reader threads. Once a reader thread reads the writer's counter, it copies its value into their counter. Having all readers with the writer's updated counter implies that the readers entered the \textit{quiescent} state ~\cite{urcu_ieee}.

In our model, the entering/exiting read-side critical section is simply abstracted as inserting/removing the reader thread's identifier to/from the \textit{readers} set(which can be implemented in a efficient way). When the reader thread exists it also removes its thread identifier from the \textit{bounding-threads} to declare that it is no longer a bounding thread.

Efficient implementations go to great lengths to minimize the cost of the read-side critical section operations while tracking the same information.  Direct implementation of our semantics would yield unacceptable performance, since both entering(\lstinline|ReadBegin|) and exiting(\lstinline|ReadEnd|) modify shared data structures for the \textit{bounding-threads} and \textit{readers} sets. Typically, implementations are structured so each reader thread (or CPU) maintains its own \emph{fragment} of the shared global state, which is only updated by that thread, but is read by the write-side primitives.

We should also note that if we had the careful implementation mentioned for the \lstinline|ReadBegin| and \lstinline|ReadEnd| then all actions(traverse and read the node value) from a reader thread would \textit{reduce} to an \textit{atomic} data value-read -- the reader threads shows logical atomicity. However, since we do not provide the careful implementation for the the \lstinline|ReadBegin| and \lstinline|ReadEnd| we cannot provide the \textit{atomicity} proof as well.
  
Finally,  once the \textit{bounding threads} set becomes empty, synchronization finishes and all the heap nodes observed by the writer thread as \textsf{unlinked} are now observed as \textsf{freeable}. 

\mypar{Complex Logical Machinery} In Figure \ref{fig:clientspeclink} we see pre/post conditions for the \textit{fresh-node-linking} action in \textsf{iGPS}. They do not seem to be much more complex than our typing judgement \textsc{T-LinkF} as the writer abstract predicate \textsf{WriterSafe} ($q$,$L$) makes them clean.
\begin{figure}[H] 
\begin{tabular}{p{\textwidth}}
\begin{lstlisting}[basicstyle=\scriptsize\ttfamily]
$\assert{\mathsf{WriterSafe}(q,L.(p,v).L')}$
[p+link]$_{acq}$  
$\assert{p'.\mathsf{WriterSafe}(q,L.(p,v).L')*((p'=0 \land L'= \text{nil}) \lor (p \neq 0 \land \exists_{L''} \ldotp v'.L' = (p',v').L''))}$
\end{lstlisting}
\end{tabular}
\vspace{-2em}
\caption{Client Specification of \textit{fresh-node-linking} in \textsf{iGPS}}
\label{fig:clientspeclink}
\end{figure}
However, in Tassarotti's model we know that the writer consumes the permission to generate a new version of the list with the updated values. The writer thread has also shares the permissions with the reader threads for simultaneous accesses on the same heap node. Not only heap data but also \textit{meta} data -- e.g. read/write counters -- needs updating/publishing. All these actions captures as Release-Acquire relations in between the writer and reader threads. Tassarotti et al. use \textit{protocols} to formalize Release-Acquire-1-2-3(explained by Tassarotti et al. in Appendix C.3.2  ~\cite{verrcu}). To do so, they define logical machinery (Partial-Commutative-Monoid(PCM) instances) for \textit{protocols} on \textit{token-exchange} to make \textit{permission/sharing} model work.

To provide full functional correctness of RCU model, you need all of the logical machineries mentioned. However, it is also worth mentioning that these machineries are not directly related to the RCU client verification and it requires a significant shift from the client memory safety reasoning to the functional correctness of RCU model. So we think that instantiating a basis logic(Iris or Views(can also be instantiated with Iris)) requires an effort on providing a clean separation between the logical machinery needed for client verification and full functional correctness of the model and this effort is important.

\mypar{Pragmatic Usage of the Abstract Predicates}  However, \textsf{WriterSafe} is composed of other abstract predicates( \textsf{RevokedUpTo}, \textsf{DeallocBetween}, \textsf{CurrentState}, \textsf{FreeValid}, \textsf{NoDup}, \textsf{TraceSpine}, \textsf{DeadFrom} in Appendix 3.2 ~\cite{verrcu}).

Our model has also similar abstract predicates, however, we think that it is important to have an idea on how the introduction of these predicates and other logical abstractions might affect a client's \textit{memory-safety} proof mostly pragmatically. For example, Tassarotti et al. introduces the abstract predicate \textsf{DeadFrom} (as a part of \textsf{WriteSafe} client abstract predicate) which iteratively asserts that there exists no unlinked heap in the \textit{deallocation stack} from the previous consistent snapshot $H_1$ that is not reclaimed by now: \textsf{dead}($H_2$)-\textsf{dead}($H_1$). Likewise, instead of \textit{deallocation stack} we keep \textit{free list} in our logical state defined in Section \ref{sec:soundness}. This logical list includes mappings from \textsf{unlinked} heap locations to \textit{bounding-threads} (or \textsf{freeable} ones if the \textit{bounding-threads} set is empty). We define our abstract predicates over this \textit{free list} either as a part of the type denotations(Figure \ref{fig:denotingtypeenviroment} Section \ref{sec:soundness}) or our global invariants for RCU memory(Appendix \ref{sec:lemmas}). Tassarotti's \textsf{SafePtr} predicate is another interesting case which asserts that a reference is pointing to a properly initialized node in the list. We assert this property in the type denotation of the writer's iterator type $\llbracket \mathsf{rcuItr}\,\rho\,\N\rrbracket$ over the next field mappings $\N$ such that all these mappings are pointing to a proper memory location.

All these \textit{separation-concerns} in the abstraction levels of specifying client's memory safety properties provide us to have predicates not refering to any specific structure of a data structure that we prove memory-safety for. So we prove all the properties(for client's memory safety) asserted by abstract predicates as a part of the \textit{soundness} proof (in Section \ref{sec:soundness} and complete proof in Appendix \ref{sec:prooflemmas})  just for once and use the same types for asserting the memory safety for different data structures e.g. a linked list in Appendix \ref{appendix:bag_paul}and a binary search tree in Appendix \ref{appendix:bst_del}.
